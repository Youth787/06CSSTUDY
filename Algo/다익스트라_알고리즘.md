# 다익스트라 알고리즘이란? 

BFS와 DP를 활용한 최단경로 탐색 알고리즘이다. 
즉, 그래프에서 출발점에서 목표점까지의 최단거리를 구할 때 사용하는 알고리즘이다. 
이 과정에서 도착 정점 뿐만 아니라 모든 다른 정점까지 최단 경로로 방문하며 각 정점까지의 최단 경로를 모두 찾게 된다. 
매번 최단 경로의 정점을 선택해 탐색을 반복하는 것이다.

# 다익스트라 알고리즘 특징 

1. 그래프 내부 하나의 정점(노드, Vertex)에서 다른 모든 정점으로 가는 최단 경로를 알려준다.
2. 그래프의 간선(Edge)마다 가중치가 존재할 때 사용 ⇒ BFS를 활용한 최단 경로 구하기와 다른 점
3. 간선의 음의 가중치는 존재하지 않는다. 음의 가중치가 하나라도 있으면 다익스트라를 사용할 수 없다.
   ⇒ 현실 세계에 사용하기 적합한 알고리즘 [ex) GPS, 내비게이션]
4. 구현
  1) 출발 노드, 도착 노드로 구성된 이차원 배열 활용 구현
  2) 각 거리에 해당하는 우선순위 큐(힙) 활용 구현

# 인접행렬 방식 구현 - 시간 복잡도 

'방문하지 않은 노드 중 거리값이 가장 작은 노드'를 선택해 다음 탐색 노드로 삼는다. 
그 노드를 찾는 방식이 순차 탐색이 된다. 
즉, 거리 테이블의 앞에서부터 찾아내야 하므로 노드의 개수만큼 순차 탐색을 수행해야 한다. 
따라서 노드 개수가 N이라고 할 때 각 노드마다 최소 거리값을 갖는 노드를 선택해야 하는 순차 탐색이 수행되므로 (N−1)×N=O(N^2)의 시간이 걸린다.

dist 값이 제일 작은 노드를 찾는 부분을 우선순위 큐를 이용하면 O(log V)로 줄일 수 있다.

<img width="763" alt="스크린샷 2023-12-26 오전 12 06 36" src="https://github.com/Youth787/SSAFY_CS_Study/assets/90955152/c95e7294-4eec-4a7e-902d-ea198cfdca3e">

1. 출발 지점의 노드가 1로 주어져 우선순위 큐에 넣는다. 출발 노드에서 출발 노드의 거리는 0이므로 0으로 초기화

<img width="829" alt="스크린샷 2023-12-26 오전 12 07 04" src="https://github.com/Youth787/SSAFY_CS_Study/assets/90955152/bb2739c8-c8ee-4fa4-bc88-c6bb5863ace5">

2. 우선순위 큐를 사용하기 때문에 거리가 가장 짧은 노드를 선택하기 위해서는 단순히 큐에서 노드를 꺼낸다. 
해당 노드를 처리한 적이 있으면 무시하고 처리하지 않은 노드에 대해서만 처리한다.
1번까지 가는 최단거리가 0이므로, 1번 노드를 거쳐 연결된 2,3번까지 가는 최소 비용을 계산한다. 
꺼낸 원소 : (거리 0, 노드 1)

<img width="816" alt="스크린샷 2023-12-26 오전 12 07 53" src="https://github.com/Youth787/SSAFY_CS_Study/assets/90955152/713b427a-1883-473a-bfd4-ae76e194bcc9">

3. 이어서 다시 우선순위 큐에서 원소를 꺼내서 동일한 과정을 반복한다. 
꺼낸 원소 : (거리 2, 노드 2)

<img width="828" alt="스크린샷 2023-12-26 오전 12 08 23" src="https://github.com/Youth787/SSAFY_CS_Study/assets/90955152/2aa91ec8-f124-4dc3-b99a-424df853eb70">

4. 3번 노드에서 4번 노드로 가는 가중치가 6이라 (3+6>7)이 되어 4번으로 가는 최단 경로는 갱신 되지 않고 넘어가게 된다. 
꺼낸 원소 : (거리 3, 노드 3)

<img width="822" alt="스크린샷 2023-12-26 오전 12 08 53" src="https://github.com/Youth787/SSAFY_CS_Study/assets/90955152/9a731438-5edb-4b09-83b0-18b9c5bcb655">

5. 해당 노드에서 5번 노드로 가는 길은 없어 큐가 비게 되고, 종료된다. 
꺼낸 원소 : (거리 7, 노드 4)

<img width="826" alt="스크린샷 2023-12-26 오전 12 09 49" src="https://github.com/Youth787/SSAFY_CS_Study/assets/90955152/a509d9ce-39f7-4063-92d2-c17fadb8a937">


# 코드 구현 

          ``` java
      
          import java.util.*;
          import java.io.*;
          
          public class Main {
      
          static class Node{
              int index; //간선
              int weight; //가중치
      
              public Node(int index, int weight) {
                  this.index = index;
                  this.weight = weight;
              }
          }
      
          static ArrayList<Node>[] graph;
          static boolean[] visit;
          static int[] dist; // 최단거리 테이블 
      
          public static void main(String[] args) throws IOException {
              BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
              StringTokenizer st = new StringTokenizer(br.readLine());
      
              int v = Integer.parseInt(st.nextToken()); // 정점
              int e = Integer.parseInt(st.nextToken()); // 간선
              int k = Integer.parseInt(br.readLine()); // 시작 정점의 번호 
              graph = new ArrayList[v + 1];
              dist = new int[v + 1];
              visit = new boolean[v + 1];
      
              for (int i = 1; i <= v; i++) {
                  graph[i] = new ArrayList<>();
                  dist[i] = Integer.MAX_VALUE; //최대값으로 초기화, 최단거리를 찾기 위함.
              }
      
              for (int i = 0; i < e; i++) {
                  // start -> end 로 가는 가중치 w가 주어진다.
                  st = new StringTokenizer(br.readLine());
                  int start = Integer.parseInt(st.nextToken());
                  int end = Integer.parseInt(st.nextToken());
                  int W = Integer.parseInt(st.nextToken());
      
                  graph[start].add(new Node(end, W)); // 방향성 존재 
              }
      
              //다익스트라 알고리즘 수행
              dijkstra(k);
      
              for (int i = 1; i <= v; i++) {
                  System.out.println(dist[i] == Integer.MAX_VALUE ? "INF" : dist[i]);
              }
          }
          static void dijkstra(int index) {
                  //우선 순위 큐 사용, 가중치를 기준으로 오름차순한다.
                  PriorityQueue<Node> q = new PriorityQueue<>((o1, o2) -> o1.cost - o2.cost);
                  //시작 노드에 대해서 초기화
                  q.add(new Node(index, 0));
                  dist[index] = 0;
          
                  while (!q.isEmpty()) {
                      //현재 최단 거리가 가장 짧은 노드를 꺼내서 방문 처리 한다.
                      Node now = q.poll();
          
                      if (!visit[now.index]) {
                          visit[now.index] = true;
                      }
          
                      for (Node next : graph[now.index]) {
          
                          //방문하지 않았고, 현재 노드를 거쳐서 다른 노드로 이동하는 거리가 더 짧을 경우
                          if (!visit[next.index] && dist[next.index] > now.weight + next.weight) {
                              dist[next.index] = now.weight + next.weight;
                              q.add(new Node(next.index, dist[next.index]));
                          }
                      }
                  }
              }
          }
          ```
